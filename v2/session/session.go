package session

import (
	_ "errors"
	"github.com/mobilemindtech/go-io/io"
	"github.com/mobilemindtech/go-io/option"
	"github.com/mobilemindtech/go-io/result"
	"github.com/mobilemindtech/go-io/types"
	"github.com/mobilemindtech/go-io/types/unit"

	"github.com/mobilemindtech/go-utils/v2/criteria"

	"fmt"
	"reflect"

	"github.com/mobilemindtech/go-utils/app/models"
	"github.com/mobilemindtech/go-utils/beego/db"
	"github.com/mobilemindtech/go-utils/v2/optional"
)

type Action struct {
	entity interface{}
}

func (this *Action) Get() interface{} {
	return this.entity
}

type ActionSave struct {
	Action
}

func NewActionSave(e interface{}) *ActionSave {
	return &ActionSave{Action{entity: e}}
}

type ActionUpdate struct {
	Action
}

func NewActionUpdate(e interface{}) *ActionUpdate {
	return &ActionUpdate{Action{entity: e}}
}

type ActionPersist struct {
	Action
}

func NewActionPersist(e interface{}) *ActionPersist {
	return &ActionPersist{Action{entity: e}}
}

type ActionRemove struct {
	Action
}

func NewActionRemove(e interface{}) *ActionRemove {
	return &ActionRemove{Action{entity: e}}
}

type ActionRemoveCascade struct {
	Action
}

func NewActionRemoveCascade(e interface{}) *ActionRemoveCascade {
	return &ActionRemoveCascade{Action{entity: e}}
}

type RxSession[T any] struct {
	session *db.Session
	actions []interface{}
	where   *criteria.Reactive
}

func WithTxOpt[T any]() *optional.Optional[*RxSession[T]] {
	s := db.NewSession()
	err := s.OpenTx()
	if err != nil {
		return optional.OfFail[*RxSession[T]](err)
	}
	val := &RxSession[T]{session: s, actions: []interface{}{}}
	return optional.Of[*RxSession[T]](val)
}

func WithNoTx[T any]() *RxSession[T] {
	s := db.NewSession()
	err := s.OpenNoTx()
	if err != nil {
		panic(err)
	}
	return New[T](s)
}

func RunWithNoTxWithTenantId[T any](id int64, f func(*RxSession[T]) T) T {
	s := db.NewSession()
	if id > 0 {
		s.Tenant = models.NewTenantWithId(id)
	}
	err := s.OpenNoTx()
	if err != nil {
		panic(err)
	}
	defer s.Close()
	return f(New[T](s))
}
func RunWithNoTx[T any](f func(*RxSession[T]) T) T {
	return RunWithNoTxWithTenantId[T](0, f)
}

func RunWithTxWithTenantId[T any](id int64, f func(*RxSession[T]) T) T {
	s := db.NewSession()
	if id > 0 {
		s.Tenant = models.NewTenantWithId(id)
	}
	err := s.OpenTx()
	if err != nil {
		panic(err)
	}
	defer s.Close()
	return f(New[T](s))
}

func RunWithTx[T any](f func(*RxSession[T]) T) T {
	return RunWithTxWithTenantId[T](0, f)
}

func WithTx[T any]() *RxSession[T] {
	s := db.NewSession()
	err := s.OpenTx()
	if err != nil {
		panic(err)
	}
	return New[T](s)
}

func WithNoTxOpt[T any]() *optional.Optional[*RxSession[T]] {
	s := db.NewSession()
	err := s.OpenNoTx()
	if err != nil {
		return optional.OfFail[*RxSession[T]](err)
	}
	val := &RxSession[T]{session: s, actions: []interface{}{}}
	return optional.Of[*RxSession[T]](val)
}

func NewDbSesion() *db.Session {
	return db.NewSession()
}

func ReadNoTx() *db.Session {
	s := NewDbSesion()
	if err := s.OpenNoTx(); err != nil {
		panic(err)
	}
	return s
}

func ReadTx() *db.Session {
	s := NewDbSesion()
	if err := s.OpenTx(); err != nil {
		panic(err)
	}
	return s
}

func New[T any](session *db.Session) *RxSession[T] {
	return &RxSession[T]{session: session, actions: []interface{}{}}
}

func (this *RxSession[T]) Load(value T) *result.Result[T] {
	opt := this.LoadOption(value)

	if opt.IsError() {
		return result.OfError[T](opt.Failure())
	}

	if opt.Get().IsNone() {
		return result.OfError[T](fmt.Errorf("row not found: %v", value))
	}

	return result.OfValue(opt.Get().Get())
}

func (this *RxSession[T]) LoadOption(value T) *result.Result[*option.Option[T]] {
	return result.Try(func() (*option.Option[T], error) {
		ok, err := this.session.Load(value)

		if err != nil {
			return option.None[T](), err
		}

		if !ok {
			return option.None[T](), nil
		}
		return option.Some(value), nil
	})
}

func (this *RxSession[T]) Close() {
	this.session.Close()
}

func (this *RxSession[T]) Where(c *criteria.Reactive) *RxSession[T] {
	this.where = c
	return this
}

func (this *RxSession[T]) AddAction(ac ...interface{}) *RxSession[T] {
	for _, it := range ac {
		this.actions = append(this.actions, it)
	}
	return this
}

func (this *RxSession[T]) RunWithTenantId(id int64, cb func(*RxSession[T]) T) T {
	var result T
	this.session.RunWithTenant(models.NewTenantWithId(id), func() {
		result = cb(this)
	})
	return result
}

func (this *RxSession[T]) AddPersist(items ...interface{}) *RxSession[T] {
	for _, o := range items {
		this.AddAction(NewActionPersist(o))
	}
	return this
}

func (this *RxSession[T]) AddPersistOf(items ...T) *RxSession[T] {
	for _, o := range items {
		this.AddPersist(o)
	}
	return this
}

func (this *RxSession[T]) AddSave(items ...interface{}) *RxSession[T] {
	for _, o := range items {
		this.AddAction(NewActionSave(o))
	}
	return this
}

func (this *RxSession[T]) AddSaveOf(items ...T) *RxSession[T] {
	for _, o := range items {
		this.AddSave(o)
	}
	return this
}

func (this *RxSession[T]) AddUpdate(items ...interface{}) *RxSession[T] {
	for _, o := range items {
		this.AddAction(NewActionUpdate(o))
	}
	return this
}

func (this *RxSession[T]) AddUpdateOf(items ...T) *RxSession[T] {
	for _, o := range items {
		this.AddUpdate(o)
	}
	return this
}

func (this *RxSession[T]) AddRemove(items ...interface{}) *RxSession[T] {
	for _, o := range items {
		this.AddAction(NewActionRemove(o))
	}
	return this
}

func (this *RxSession[T]) AddRemoveOf(items ...T) *RxSession[T] {
	for _, o := range items {
		this.AddRemove(o)
	}
	return this
}

func (this *RxSession[T]) AddRemoveCascade(items ...interface{}) *RxSession[T] {
	for _, o := range items {
		this.AddAction(NewActionRemoveCascade(o))
	}
	return this
}

func (this *RxSession[T]) AddRemoveCascadeOf(items ...T) *RxSession[T] {
	for _, o := range items {
		this.AddRemoveCascade(o)
	}
	return this
}

func (this *RxSession[T]) Exec() *optional.Optional[bool] {
	r := this.Run()
	switch r.Val().(type) {
	case *optional.Some:
		return optional.Of[bool](true)
	}
	return optional.Of[bool](r.Val())
}

func (this *RxSession[T]) ExecWhere(c *criteria.Reactive) *optional.Optional[bool] {
	this.Where(c)
	return this.Exec()
}

func (this *RxSession[T]) Run() *optional.Optional[T] {

	if this.where != nil {
		first := this.where.Any()
		r := optional.Of[bool](first.Get())

		if r.IsFail() {
			return optional.OfFail[T](r.GetFail())
		}

		if r.UnWrap() {
			return optional.OfOk[T]()
		}
	}

	for _, ac := range this.actions {

		var err error

		switch ac.(type) {
		case *ActionSave:
			err = this.session.Save(ac.(*ActionSave).Get())
			break
		case *ActionUpdate:
			err = this.session.Update(ac.(*ActionUpdate).Get())
			break
		case *ActionPersist:
			err = this.session.SaveOrUpdate(ac.(*ActionPersist).Get())
			break
		case *ActionRemove:
			err = this.session.Remove(ac.(*ActionRemove).Get())
			break
		case *ActionRemoveCascade:
			err = this.session.RemoveCascade(ac.(*ActionRemoveCascade).Get())
			break
		default:
			err = fmt.Errorf("invalid action: %v", reflect.TypeOf(ac))
		}

		if err != nil {
			return optional.OfFail[T](err)
		}
	}

	return optional.OfOk[T]()
}

func (this *RxSession[T]) Save(entity T) *optional.Optional[T] {

	if err := this.session.Save(entity); err != nil {
		return optional.OfFail[T](err)
	}
	return optional.OfSome[T](entity)
}

func (this *RxSession[T]) SaveCascade(entity T) *optional.Optional[T] {

	if err := this.session.SaveCascade(entity); err != nil {
		return optional.OfFail[T](err)
	}
	return optional.OfSome[T](entity)
}

func (this *RxSession[T]) Update(entity T) *optional.Optional[T] {

	if err := this.session.Update(entity); err != nil {
		return optional.OfFail[T](err)
	}
	return optional.OfSome[T](entity)
}

func (this *RxSession[T]) UpdateCascade(entity T) *optional.Optional[T] {

	if err := this.session.Update(entity); err != nil {
		return optional.OfFail[T](err)
	}
	return optional.OfSome[T](entity)
}

func (this *RxSession[T]) Remove(entity T) *optional.Optional[bool] {

	if err := this.session.Remove(entity); err != nil {
		return optional.OfFail[bool](err)
	}
	return optional.OfSome[bool](true)
}

func (this *RxSession[T]) RemoveCascade(entity T) *optional.Optional[bool] {

	if err := this.session.RemoveCascade(entity); err != nil {
		return optional.OfFail[bool](err)
	}
	return optional.OfSome[bool](true)
}

func (this *RxSession[T]) Persist(entity T) *optional.Optional[T] {

	if err := this.session.SaveOrUpdateCascade(entity); err != nil {
		return optional.OfFail[T](err)
	}
	return optional.OfSome[T](entity)
}

func (this *RxSession[T]) PersistResult(entity T) *result.Result[T] {
	if err := this.session.SaveOrUpdateCascade(entity); err != nil {
		return result.OfError[T](err)
	}
	return result.OfValue(entity)
}

// Persiste all and return entity. Persists entity last
func (this *RxSession[T]) PersistLastWithBatch(entity T, entities ...interface{}) *result.Result[T] {

	for _, it := range entities {
		if err := this.session.SaveOrUpdateCascade(it); err != nil {
			return result.OfError[T](err)
		}
	}

	if err := this.session.SaveOrUpdateCascade(entity); err != nil {
		return result.OfError[T](err)
	}
	return result.OfValue(entity)
}

// Persiste all and return entity. Persists entity first
func (this *RxSession[T]) PersistFirstWithBatch(entity T, entities ...interface{}) *result.Result[T] {

	if err := this.session.SaveOrUpdateCascade(entity); err != nil {
		return result.OfError[T](err)
	}

	for _, it := range entities {
		if err := this.session.SaveOrUpdateCascade(it); err != nil {
			return result.OfError[T](err)
		}
	}

	return result.OfValue(entity)
}

func (this *RxSession[T]) PersistBatch(entities ...interface{}) *result.Result[*unit.Unit] {

	for _, it := range entities {
		if err := this.session.SaveOrUpdateCascade(it); err != nil {
			return result.OfError[*unit.Unit](err)
		}
	}

	return result.OfValue(unit.OfUnit())
}

func (this *RxSession[T]) PersistIO(entity T) *types.IO[T] {
	return io.IO[T](
		io.Attempt(
			func() *result.Result[T] {
				return this.PersistResult(entity)
			}))
}

func (this *RxSession[T]) FindOrCreate(entity T, c *criteria.Reactive) *result.Result[T] {

	first := c.First()
	r := optional.Of[T](first.Get())

	if !r.IsFail() && r.IsNone() {
		return result.Try(func() (T, error) {
			return entity, this.session.Save(entity)
		})
	}

	return r.AsResult()
}

func (this *RxSession[T]) RowsF(query string, args ...interface{}) func(func(*db.Row) T) ([]T, error) {
	return func(f func(*db.Row) T) ([]T, error) {
		vals, err := this.session.Rows(query, args...)
		if err != nil {
			return nil, err
		}
		var items []T
		for _, it := range vals {
			items = append(items, f(it))
		}
		return items, nil
	}
}

func (this *RxSession[T]) FirstRowResultF(query string, args ...interface{}) func(func(*db.Row) T) *result.Result[*option.Option[T]] {
	return func(f func(*db.Row) T) *result.Result[*option.Option[T]] {
		val, err := this.FirstRowF(query, args...)(f)
		if err != nil {
			return result.OfError[*option.Option[T]](err)
		}

		return result.OfValue(option.Of(val))
	}
}
func (this *RxSession[T]) FirstRowF(query string, args ...interface{}) func(func(*db.Row) T) (T, error) {
	return func(f func(*db.Row) T) (T, error) {
		val, err := this.session.FirstRow(query, args...)
		var x T
		if err != nil {
			return x, err
		}
		if val != nil {
			return f(val), nil
		}
		return x, nil
	}
}
